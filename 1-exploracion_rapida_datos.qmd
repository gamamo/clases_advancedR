---
title: "Exploración rápida de datos"
author: "Gabriel Massaine Moulatlet"
institute: Instituto de Ecología, A.C.
format: revealjs
editor: visual
highlight-style: arrow-light
---

# Exploración de datos

## Paquetes

Vamos a utilizar los seguientes paquetes en R

-   skimR
-   janitor
-   easystats

![](C:/Users/gabri/Dropbox/postdocINECOL/Curso%20Analisis%20avanzados%20en%20R/images/figlogos.png)

------------------------------------------------------------------------

> "Los científicos de datos, según entrevistas y estimaciones de expertos, dedican entre el 50 % y el 80 % de su tiempo a este labor más mundano de recopilar y preparar datos digitales rebeldes, antes de que puedan explorarse en busca de pepitas útiles."

![](C:/Users/gabri/Dropbox/postdocINECOL/Curso%20Analisis%20avanzados%20en%20R/images/meme_data.jpg){fig-align="center"}

## Janitor

![](C:/Users/gabri/Dropbox/postdocINECOL/Curso%20Analisis%20avanzados%20en%20R/images/janitor.png){width="1mm" fig-align="right"}

## Uso de la función *table()* del R base

Esta función sirve para generar tablas de contingencia, o sea, con frecuencias, proporciones o conteos entre los objetos

```{r}
#| eval: true
#| echo: true
# vamos crear un data.frame
df <- data.frame(nacionalidad = c("ARG","NOR","FRA","ARG","ARG","ARG","ARG"),
                 jugadores = c('Messi', 'Haaland', 'Benzema', 'Alvarez', 'Lautaro',
                               'DiMaria','Maradona'),
                 goles = c(12, 30, 30, 12, 12,30,NA),
                 partidos = c(15, 20, 20, 20, 18,20,NA))
print(df)
```

------------------------------------------------------------------------

```{r}
#| eval: true
#| echo: true
# Cuantas "categorias" de goles hay?
table(df$goles)

# Cruzar la información "jugadores" y "goles"
table(df$jugadores,df$goles)
```

## Podemos usar proporciones

```{r}
#| eval: true
#| echo: true

prop.table(table(df$jugadores,df$goles))
```

## Desventajas de usar la función table()

-   el output no es un data.frame
-   no funciona bien con los %\>% pipes
-   los resultados son complicados de formatear

```{r}
#| eval: true
#| echo: true

tab <- table(df$jugadores,df$goles)
class(tab)
```

## Uso de la función `tabyl()`

-   usa la estructura tidyverse
-   publica mas informaciones relevantes

```{r}
#| eval: true
#| echo: true
library(janitor)
library(dplyr)

# Tablas con una variable
df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(jugadores)
```

## Tablas con NA

```{r}
#| eval: true
#| echo: true

df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(goles)
```

## Uso de la función `adorn_()`

Algunas funciones derivadas útiles

-   `adorn_totals()`
-   `adorn_percentages()`
-   `adorn_rounding(digits=1)`

```{r}
#| eval: true
#| echo: true

df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(goles) %>%
  adorn_totals()

```

## Tablas con dos variables

```{r}
#| eval: true
#| echo: true

df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(goles,partidos) %>%
  adorn_percentages()
```

> QUIZ: Al usar la función `adorn_percentages()`, qué porcentajes se están calculando? Hay un argumento llamado *denominator = c("all", "row", "col")* en la función `adorn_percentages()`. Cuál es la diferencia en usar cada una de las opciones?

## 

No confundir:

-   `adorn_percentages()` - calcular porcentajes
-   `adorn_pct_formatting()` - formatar los valores calculados
-   ambas funciones pueden ser usadas una trás otra

```{r}
#| eval: true
#| echo: true

df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(goles,partidos) %>%
  adorn_percentages() %>%
  adorn_pct_formatting()

```

## Función adicional: - `adorn_ns()`

```{r}
#| eval: true
#| echo: true

df %>%
  filter(nacionalidad == "ARG") %>%
  tabyl(goles,partidos) %>%
  adorn_percentages() %>%
  adorn_pct_formatting() %>%
  adorn_ns()

```

## función bonus `top_levels()`

-   sirve para obtener la tabla de frecuencias de un vector de factores
-   separa los factores en 3 grupos *bajo*, *medio*, *alto*
-   la función `top_levels()` te devuelve un data.frame

## 

```{r}
#| eval: true
#| echo: true

fac <- as.factor(c("muy fuerte","muy fuerte","muy fuerte","fuerte","débil","débil","muy débil","muy débil"))

top_levels(fac)
top_levels(fac,n=1) # n es el numero de níveles en las categorias *bajo* y *alto*
```

## 

![](C:/Users/gabri/Dropbox/postdocINECOL/Curso%20Analisis%20avanzados%20en%20R/images/bernie.jpg)

# skimR
