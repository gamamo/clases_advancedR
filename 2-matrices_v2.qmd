---
title: "Matrices en Ecología"
author: "Gabriel Massaine Moulatlet"
institute: Instituto de Ecología, A.C.
format: 
  revealjs:
    slide-number: true
editor: visual
highlight-style: arrow-light
---

# Matrices

## Matrices en Ecología

![](https://i.imgflip.com/lnf8o.jpg)

## 
-   Es el formato más comun de formatación de datos ecológicos
-   Se torno popular en ecologia con el desarollo de mejores computadoras
-   Gran parte del lenguaje de los softwares está basada en notaciones de matrices 

## La matrix
![](imgs/matrix.jpg)

## La matrix de asociación
- Similitud o Distancias
- numero de filas tiene que ser igual al numero de columnas

![](imgs/amatrix.jpg)

## Matrices de una columna (o *vectores*)
- *scaling* que usamos en las PCAs
- Para comparar diferentes vectores

![](imgs/vector.jpg)

## Son muy usadas en los analisis de ecologia
- Analisis multivariadas en ecologia de comunidades
- Para sumarizar grandes conjuntos de datos
- En las estadísticas empleadas en modelos estadísticos (lm, pglm, gls etc)
- Muy comunes en macroecología (matrix de presencia-ausencia)

## Matrices en R
-   `matrix()`vs. `data.frame()` vs. `array()`
-   `matrix()`: solo numeros o solo caracteres
-   `data.frame()`: mix de tipos numeros y caracteres
-   `array()` son *n*-dimensionales

## Estructura de la matriz
-   una matriz es un tipo especial de `array()`
-   una matriz tiene 2 dimensiones, formadas por filas y columnas

```{r}
#| eval: true
#| echo: true

matrix(data=NA, nrow = 2, ncol=2)

```

## Pueden encontrar las diferencias entre `matrix()` y `array()`?
- Qué diferencia(s) econtraron?
```{r}
#| eval: true
#| echo: true

a <- matrix(1:16, ncol = 3, nrow = 2)
b <- array(1:12, c(2, 3, 4))
diag(a)

```


## los argumentos
-   *dimnames*
-   una lista con los nombres de las filas y de las columnas, respectivamente

```{r}
#| eval: true
#| echo: true

matrix(data=NA, nrow = 2, ncol=2,dimnames = list(c("row1","row2"),
                                                 c("col1", "col2")))
```

## Llenado de matriz
-   *byrow*
-   define como se da el llenado de la matrix
-   si `byrow=T`, el llenad se da por filas

```{r}
#| eval: true
#| echo: true
vec = c("a","b","c","d","e","f")
matrix(vec, nrow = 3, byrow = T )
```

## si `byrow=F`, el llenado se da por columnas
```{r}
#| eval: true
#| echo: true
vec = c("a","b","c","d","e","f")
matrix(vec, nrow = 3, byrow = F )
```

## `diag()`
- Es la función para extraer la diagonal de una matriz
```{r}
#| eval: true
#| echo: true
a <- matrix(1:16, ncol = 3, nrow = 2)
diag(a)
```

# Algebra de matrices

## Operaciones con matrices: Sumatoria
```{r}
#| eval: true
#| echo: true
 a <- matrix(1:9, nrow=3)
 b <- diag(rep(1,3))
 
 a + b

```

## Operaciones con matrices: Diferencia
```{r}
#| eval: true
#| echo: true
 a <- matrix(1:9, nrow=3)
 b <- diag(rep(1,3))
 
 a - b
```

## Operaciones con escalares
```{r}
#| eval: true
#| echo: true
 a <- matrix(1:9, nrow=3)
 d <- c(0,0,1)

 a + d
 
 a + 1

```

## pero...
- a + b y a + b2 son iguales?
```{r}
#| eval: true
#| echo: true

 a <- matrix(1:9, nrow=3)
 b <- 1
 b2 <- matrix(b, nrow=1)
 
 a + b
```

## Y esta suma, sale bien?
```{r}
#| eval: false
#| echo: true
 
 a + b2
```
## Multiplicación de matrices

```{r}
#| eval: true
#| echo: true

a <- matrix(1:9, nrow=3)
b <- diag(rep(1,3))
d <- matrix(c(0,0,1), nrow=3)
```

El comando `%*%` se aplica par las multiplicaciones

```{r}
#| eval: false
#| echo: true

 a %*% b # Salió bien?
 a %*% d # esta?
 d %*% a # y esta?
```

## División de matrices no existen, se las multiplica por el inverso
- La función `solve()` calcula el inverso
- No confundir con `t()`, que es la función para trasponer la matriz
```{r}
#| eval: true
#| echo: true

a <- rbind(c(10,5,5), c(5,10,2), c(5,2,10))
ainv <- solve(a)
ainv
```

##
```{r}
#| eval: true
#| echo: true
a %*% ainv
```
Pueden mirar el resultado usando la función `round()`...queda mejor


## QUIZ
- Un pesticida tiene 2 compuestos tóxicos I y II que se acumulan en 3 especies de plantas A, B y C 

```{r}
#| eval: true
#| echo: true
M = matrix(c(2,3,4,0,1,2), nrow=2,ncol=3,byrow=T,dimnames = list(c("I","II"),
                                                                   c("A", "B","C")))
M
```

##
- Si un herbívoro se alimenta de estas 3 especies en las seguientes cantidades por día:
```{r}
#| eval: true
#| echo: true

N = matrix(c(5,3,1), nrow=3,ncol=1,byrow=F,dimnames = list(c("A","B","C")))
                                                                   
N
```
- ?Cuantos contaminantes I y II consume diariamente?
- Tip: Mirar el producto de M x N

# Tipos de matriz en R

## *Sparse* vs. *Dense* matrices
- paquete `Matrix`
- Documentación [aqui](https://ocw.mit.edu/courses/18-335j-introduction-to-numerical-methods-spring-2019/bcd746dca8cbf0d5a890f01a72d8ef64_MIT18_335JS19_lec24.pdf)

![](imgs/sparse.png){fig-align="center"}


## *Sparse* vs. *Dense* matrices
- Funciones aplicadas a ambos tipos de matrices producen los mismos resultado
- Tiene ventajas en el tiempo de procesamiento de datos

##
:::columns
:::{.column width="50%"}
- `Dense`
```{r}
#| eval: true
#| echo: true
library(Matrix)
M <- Matrix(10 + 1:28, 4, 7)
M2 <- cbind(-1, M)

M2[, c(2,4:6)] <- 0
M2[2, ] <- 0
M2 <- rbind(0, M2, 0)
M2[1:2,2] <- M2[3,4:5] <- NA
```
:::
::: {.column width="50%"}
- `Sparse`
```{r}
#| eval: true
#| echo: true
library(Matrix)
M <- Matrix(10 + 1:28, 4, 7)
M2 <- cbind(-1, M)

M2[, c(2,4:6)] <- 0
M2[2, ] <- 0
M2 <- rbind(0, M2, 0)
M2[1:2,2] <- M2[3,4:5] <- NA
sM <- as(M2, "sparseMatrix")
sM
```
:::
:::


## En ecología de comunidades
- Matrices son usadas para guardar los elementos de analisis de diversidad
- Tiene muchos ceros (presencia-ausencia)
- R tiene que guardar cada valor en matrices del tipo *dense*
- Matrices del tipo *sparse* no guardan los ceros

## Funciones útiles en el paquete `phyloregion`
- Para datos de comunidades (sitios x species)
- [Phyloregion](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13478g)

##
![](imgs/phylo.jpg)

## Matrices de distancia
-   Pueden ser transformadas en objetos de distancias `dist()`

```{r}
#| eval: true
#| echo: true
x <- matrix(rnorm(25), nrow = 5)
y=dist(x)
print(y)
```

```{r}
#| eval: true
#| echo: true
x <- matrix(rnorm(25), nrow = 5)
y=dist(x)
class(y)
```

## Funciones del paquete `vegan()`

- Análisis comunes en ecología de comunidades usan el formato *dist*
- [vegdist()](https://www.rdocumentation.org/packages/vegan/versions/2.6-4/topics/vegdist)

```{r}
#| eval: true
#| echo: true
library(vegan)

data(varespec)
vare.dist <- vegdist(varespec)
class(vare.dist)

```

# Visualización de matrices

## Visualizar datos crudos
![](imgs/warton.png)

## Uso de gráficos *genéricos*
- A partir de una matriz de species x sitios
- Nos permiten visualizar patrones de la comunidad
- Asociar los patrones a teorias ecológicas

## Gausch 1982

![](imgs/DA4.png)

## Hacer gráficos genéricos
![](imgs/DA.png)

## Uso de análisis de gradientes (in)directos
![](imgs/DA2.png)

## Interpretación de los resultados
![](imgs/DA3.png)

## Cálculo de gradiente directo
![](imgs/DA5.png)

## Ejemplo usando dados de abundancia de moluscos
- Importar el archivo `moluscos.txt`
```{r}
#| eval: true
#| echo: true
library(rio)
moluscos = import(file="dados/moluscos.txt",setclass = "data.frame")

rownames(moluscos) = moluscos[,1]
moluscos = moluscos[,-1]

# importar los datos ambientales
ambi = import(file="dados/ambi.txt",setclass = "data.frame")

```

# calcular las medias 
- usar el gradiente de precipitacion
```{r}
#| eval: true
#| echo: true

molu.medias <-colSums(moluscos*ambi$lluvia)/colSums(moluscos)

```
- Ordenar las filas de acuerdo con el gradiente ambiental y con las medias

```{r}
#| eval: true
#| echo: true


molu.ord1<-moluscos[order(ambi$lluvia,decreasing=F),]
molu.ord<-molu.ord1[,order(molu.medias,decreasing=T)]	

```

## Visualizar
- Qué vemos en la gráfica abajo? Hay algun patrón?
```{r}
#| eval: true
#| echo: true

library(ggpubr)

ggballoonplot(t(molu.ord))

```
## otras opiciones de gráficos genéricos
- ver el github de Cristian Dambros, de la UFSM-BRA
- la función [poncho](https://raw.githubusercontent.com/csdambros/R-functions/master/poncho.R)

## Cuando no hay variables ambientales
- Igual se puede ordenar las matrices para visualizar los patrones
- *Indirect* gradient analysis
- De este tipo se análisis se derivan técnicas más complejas como RA, CA y PCA

## Transformar matrices: formatos *long* y *wide*
- Habia una excelente documentación [aqui](https://seananderson.ca/2013/10/19/reshape/)
- Sin emmbargo el paquete `reshape2` ya no se va actualizar
- Su funciones fueron incorporadas por el paqute *tidyr*
- Pero hay opciones en el paquete [`data.table`](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html)

## Formatos *long* y *wide*

![](imgs/reshape.png)

## en `tidyr`
- de *long* para *wide* : `tidyr::pivot_wider()`
- de *wide* para *long* : `tidyr::pivot_longer()`
- Documentación [aqui](https://tidyr.tidyverse.org/articles/pivot.html)

## Algunos ejemplos:
- Wide to long
```{r}
#| eval: true
#| echo: true

library(rio)
library(tidyr)
moluscos = import(file="dados/moluscos.txt",setclass = "data.frame")
moluscos$sites = rownames(moluscos)

mol_long = 
moluscos %>% 
  pivot_longer(
    cols = !sites,
    names_to = "species",
    values_to = "abundances")
```

## Long to wide:
- Cómo quedaria?...
- Usen la función `pivot_wider()`
```{r}
#| eval: false
#| echo: true

mol_long %>% 
  pivot_wider(
    names_from = xxx,
    values_from = xx
  )
```

## En Resumen
![](imgs/whatever.jpg)

## En serio
- La matriz es una de los formatos esenciales para los analisis ecológicos
- Manejar y visualizar información de matrices puede revelar informaciones importantes de los datos antes mismo de los análisis